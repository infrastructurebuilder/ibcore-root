<model xmlns="http://codehaus-plexus.github.io/MODELLO/1.8.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://codehaus-plexus.github.io/MODELLO/1.8.0 http://codehaus-plexus.github.io/modello/xsd/modello-1.8.0.xsd"
  java.suppressAllWarnings="false"
  xml.namespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}"
  xml.schemaLocation="https://resources.infrastructurebuilder.org/xsd/IBDataSet-${apiVersion}"
  xsd.namespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}"
  xsd.targetNamespace="https://resources.infrastructurebuilder.org/IBDataSet/${apiVersion}">
  <id>datasource</id>
  <name>IBDataSourceModel</name> <!--  Must be a single (no spaces, no dashes, no periods) identifier in order to create reader/writer -->
  <description>Mechanism to read config for an IBDataSource</description>

  <defaults>
    <default>
      <key>package</key>
      <value>${project.groupId}.model</value>
    </default>
  </defaults>
  <versionDefinition>
    <type>field</type>
    <value>modelVersion</value>
  </versionDefinition>
  <classes>
  <!-- MODEL -->
    <class xml.tagName="dataSet" rootElement="true"
      java.clone.hook="mutatingDataSetCloneHook" java.clone="deep">
      <name>DataSet</name>
      <description>
        <![CDATA[
        The <code>&lt;dataSet&gt;</code> element is the root of the configuration.
        ]]>
      </description>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataSetIdentifier]]>
        </interface>
        <interface>
          <![CDATA[java.lang.Comparable<org.infrastructurebuilder.data.IBDataSetIdentifier>]]>
        </interface>
      </interfaces>
      <fields>

        <!-- ====================================================================== -->
        <!-- Deployment Version                                                          -->
        <!-- ====================================================================== -->
        <field>
          <name>modelVersion</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Declares to which version of project descriptor this configuration conforms.  This value is the api version (major.minor) of ibdata-api and conforms to semantic versioning</description>
          <type>String</type>
        </field>


        <field>
          <name>groupId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Namespace of the dataset.  This defaults to the project.groupId of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>artifactId</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Artifact Identifier of the dataset.  This defaults to the project.artifactId of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>version</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Version of the dataset.  This defaults to the project.version of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the dataset.  This is the UUID from the Checksums of all the DataStream elements</description>
          <type>String</type>
        </field>
        <field>
          <name>dataSetName</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the dataset.  This defaults to the project.name of the building project</description>
          <type>String</type>
        </field>
        <field>
          <name>dataSetDescription</name>
          <version>1.0.0+</version>
          <description>A detailed description of the dataset.  This defaults to the project.description of the building project</description>
          <type>String</type>
        </field>
        <field xml.format="yyyy-MM-dd'T'HH:mm:ss.SSS">
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>A Date that is very close to the moment when this DataSet was persisted.  It has essentially no relationship to when the streams were read, except that it must be later.</description>
          <type>Date</type>
        </field>
        <field>
          <name>streams</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Instances of DataStreams</description>
          <association>
            <type>DataStream</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field>
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
        <field>
          <name>path</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes a path to the dataset</description>
          <type>String</type>
        </field>
      </fields>
      <codeSegments>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Default constructor (Must do this if you supply a constructor)
  public DataSet() {
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Copy constructor
  public DataSet(DataSet ds) {
    this.setArtifactId(ds.getArtifactId());
    this.setCreationDate(ds.getCreationDate());
    this.setDataSetDescription(ds.getDataSetDescription());
    this.setDataSetName(ds.getDataSetName());
    this.setGroupId(ds.getGroupId());
    this.setMetadata(ds.getMetadata());
    this.setModelVersion(ds.getModelVersion());
    this.setPath(ds.getPath());
    this.setStreams(ds.getStreams().stream().map(DataStream::new).collect(java.util.stream.Collectors.toList()));
    this.setUuid(ds.getUuid());
    this.setVersion(ds.getVersion());
  }
  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  private void mutatingDataSetCloneHook(DataSet ds) {
    if (streams != null)
      ds.getStreams().forEach(s -> s.setPath(org.infrastructurebuilder.data.IBDataModelUtils.relativizePath(ds, s)));
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  // Hashcode and equals
  @Override
  public int hashCode() {
    return java.util.Objects.hash(artifactId, creationDate, dataSetDescription, dataSetName, groupId, metadata, modelEncoding,
        modelVersion, path, streams, uuid, version);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    DataSet other = (DataSet) obj;
    return java.util.Objects.equals(artifactId, other.artifactId)
        && java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(dataSetDescription, other.dataSetDescription)
        && java.util.Objects.equals(dataSetName, other.dataSetName)
        && java.util.Objects.equals(groupId, other.groupId)
        && java.util.Objects.equals(metadata, other.metadata)
        && java.util.Objects.equals(modelEncoding, other.modelEncoding)
        && java.util.Objects.equals(modelVersion, other.modelVersion)
        && java.util.Objects.equals(path, other.path)
        && java.util.Objects.equals(uuid, other.uuid)
        && java.util.Objects.equals(version, other.version)
        && java.util.Objects.equals(streams, other.streams)
        ;
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getName() {
    return java.util.Optional.ofNullable(getDataSetName());
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getDescription() {
    return java.util.Optional.ofNullable(getDataSetDescription());
  }

  ]]>
          </code>
        </codeSegment>



        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int compareTo(org.infrastructurebuilder.data.IBDataSetIdentifier that) {
    return IBDataSetIdentifierComparator.compare(this, that);
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            //
            // ID mapper Work
            //
  @Override
  public java.util.UUID getId() {
     return org.infrastructurebuilder.data.IBDataModelUtils.safeMapUUID.apply(getUuid()).orElse(null);
  }            ]]>
          </code>
        </codeSegment>
      </codeSegments>

    </class>
    <class xml.tagName="dataStream"
      java.clone.hook="mutatingDataStreamCloneHook" java.clone="deep">
      <name>DataStream</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataStreamIdentifier]]>
        </interface>
        <interface>
          <![CDATA[java.lang.Comparable<org.infrastructurebuilder.data.IBDataStreamIdentifier>]]>
        </interface>
      </interfaces>
      <description>
        <![CDATA[
        The <code>&lt;dataSet&gt;</code> element contains information about a set of DataStream instances.
        ]]>
      </description>
      <fields>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the datastream, which is the UUID of the bytes of the checksum of the data.</description>
          <type>String</type>
        </field>
        <field>
          <name>dataStreamName</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>The full name of the datastream.</description>
          <type>String</type>
        </field>
        <field>
          <name>dataStreamDescription</name>
          <version>1.0.0+</version>
          <description>A detailed description of the datastream</description>
          <type>String</type>
        </field>
        <field>
          <name>mimeType</name>
          <version>1.0.0+</version>
          <description>Stringified version of a MIME type for the datastream</description>
          <required>true</required>
          <defaultValue>application/octet-stream</defaultValue>
          <type>String</type>
        </field>
        <field>
          <name>creationDate</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Creation date of this stream, required</description>
          <type>Date</type>
        </field>
        <field>
          <name>sourceURL</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>URL of the source of this stream, if available</description>
          <type>String</type>
        </field>
        <field>
          <name>sha512</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Sha-512 Checksum  of the source of this stream</description>
          <type>String</type>
        </field>
        <field>
          <name>metadata</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Additional metadata</description>
          <type>DOM</type>
        </field>
        <field>
          <name>path</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Describes a path to the stream</description>
          <type>String</type>
        </field>
        <field>
          <name>structuredDataDescriptor</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Optional DataStreamStructuredMetadata element for datastream</description>
          <association>
            <type>DataStreamStructuredMetadata</type>
            <multiplicity>1</multiplicity>
          </association>
        </field>

      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Default constructor
  public DataStream() {
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // "Copy constructor"
  public DataStream(DataStream ds) {
    this.setCreationDate(ds.getCreationDate());
    this.setDataStreamDescription(ds.getDataStreamDescription());
    this.setDataStreamName(ds.getDataStreamName());
    this.setMetadata(ds.getMetadata());
    this.setMimeType(ds.getMimeType());
    this.setPath(ds.getPath());
    this.setSha512(ds.getSha512());
    this.setSourceURL(ds.getSourceURL());
    this.setUuid(ds.getUuid());
  }
            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  private void mutatingDataStreamCloneHook(DataStream s) {
  }

  ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // hash and equals


  @Override
  public int hashCode() {
    return java.util.Objects.hash(creationDate, dataStreamDescription, dataStreamName, metadata, mimeType, path, sha512,
        sourceURL, uuid);
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    DataStream other = (DataStream) obj;
    return java.util.Objects.equals(creationDate, other.creationDate)
        && java.util.Objects.equals(dataStreamDescription, other.dataStreamDescription)
        && java.util.Objects.equals(dataStreamName, other.dataStreamName) && java.util.Objects.equals(metadata, other.metadata)
        && java.util.Objects.equals(mimeType, other.mimeType) && java.util.Objects.equals(path, other.path)
        && java.util.Objects.equals(sha512, other.sha512) && java.util.Objects.equals(sourceURL, other.sourceURL)
        && java.util.Objects.equals(uuid, other.uuid);
  }


            ]]>
          </code>
        </codeSegment>


        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public int compareTo(org.infrastructurebuilder.data.IBDataStreamIdentifier that) {
    return ibDataStreamComparator.compare(this, that);
  }
            ]]>
          </code>
        </codeSegment>

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            //
            // ID mapper Work
            //
  @Override
  public java.util.UUID getId() {
     return org.infrastructurebuilder.data.IBDataModelUtils.safeMapUUID.apply(getUuid()).orElse(null);
  }            ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Typed source url access
  @Override
  public java.util.Optional<String> getURL() {
    return java.util.Optional.ofNullable(getSourceURL());

  }
  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getName() {
    return java.util.Optional.ofNullable(getDataStreamName());
  }

  ]]>
          </code>
        </codeSegment>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  @Override
  public java.util.Optional<String> getDescription() {
    return java.util.Optional.ofNullable(getDataStreamDescription());
  }

  ]]>
          </code>
        </codeSegment>

<!--

        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
  private java.util.Optional<String> getValidatedSha512() {
    if (this.sha512 != null  && this.sha512.length() != 128)
      throw  new org.infrastructurebuilder.data.IBDataException("sha512 length must be 128 ");
    return java.util.Optional.ofNullable(getSha512());
  }
            // Checksum
  @Override
  public org.infrastructurebuilder.util.artifacts.Checksum getChecksum() {
    return getValidatedSha512()
      .map(org.infrastructurebuilder.util.artifacts.Checksum::new)
      .orElseThrow(() -> new org.infrastructurebuilder.data.IBDataException("No sha512 available"));
  }
  ]]>
          </code>
        </codeSegment>
-->
      </codeSegments>
    </class>
    <class locationTracker="locations" java.clone="shallow">
      <name>DataSetInputLocation</name>
      <version>1.0.0+</version>
      <fields>
        <!-- line, column and source fields are auto-generated by Modello -->
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[

    @Override
    public String toString()
    {
        return getLineNumber() + " : " + getColumnNumber() + ", " + getSource();
    }
            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
    <class sourceTracker="source" java.clone="shallow">
      <name>DataSetInputSource</name>
      <version>1.0.0+</version>
      <fields>
        <field>
          <name>modelId</name>
          <version>1.0.0+</version>
          <type>String</type>
          <description>
            <![CDATA[
            The identifier of the deployment model in the format {@code <groupId>:<artifactId>:<version>}.
            ]]>
          </description>
        </field>
        <field>
          <name>location</name>
          <version>1.0.0+</version>
          <type>String</type>
          <description>
            <![CDATA[
            The path/URL of the deployment model or {@code null} if unknown.
            ]]>
          </description>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    @Override
    public String toString()
    {
        return getModelId() + " " + getLocation();
    }
            ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>

    <class xml.tagName="structuredFieldMetadata" java.clone="deep">
      <name>StructuredFieldMetadata</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataStructuredDataFieldMetadata]]>
        </interface>
      </interfaces>
      <fields>
        <field>
          <name>index</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>Describes the field within the structured metadata that this SFM describes, from a base of 0.  Default value set to -1 to ensure setting proper index</description>
          <type>int</type>
          <defaultValue>-1</defaultValue>
        </field>
        <field>
          <name>iBDataStructuredDataMetadataType</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>"name()" of an enumerated type from IBDataStructuredDataMetadataType. Not required, but strongly encouraged.</description>
          <type>String</type>
        </field>
        <field>
          <name>enumerations</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Shows the list of (ordinal) enums that this field posseses.  If not present, this is not assumed to not be an enum</description>
          <association>
            <type>String</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
        <field>
          <name>max</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes the "maximum length" of the data in the field. This is mostly useful for string (i.e. targeted to varchar) types. Length -2 means unset (for nullability purposes)</description>
          <type>int</type>
          <defaultValue>-2</defaultValue>
        </field>
        <field>
          <name>min</name>
          <version>1.0.0+</version>
          <required>false</required>
          <description>Describes the "minimum length" of the data in the field.  Assume an actually null field has a -1 length. Length -2 means unset (for nullability purposes)</description>
          <type>int</type>
          <defaultValue>-2</defaultValue>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
    public void setType(org.infrastructurebuilder.data.IBDataStructuredDataMetadataType t) {
        this.setIBDataStructuredDataMetadataType(java.util.Objects.requireNonNull(t, "IBDataStructuredDataMetadataType is null").name());
    }            ]]>
          </code>
        </codeSegment>
<!--
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  private void mutatingDataStreamStructuredMetadataCloneHook(DataStreamStructuredMetadata s) {
  }

  ]]>
          </code>
        </codeSegment>
 -->
      </codeSegments>
    </class>

    <class xml.tagName="dataStreamStructuredMetadata"
      java.clone.hook="mutatingDataStreamStructuredMetadataCloneHook"
      java.clone="deep">
      <name>DataStreamStructuredMetadata</name>
      <version>1.0.0+</version>
      <interfaces>
        <interface>
          <![CDATA[org.infrastructurebuilder.data.IBDataStructuredDataMetadata]]>
        </interface>
      </interfaces>
      <fields>
        <field>
          <name>uuid</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>UUID identifier of the datastream that this metadata references</description>
          <type>String</type>
        </field>
        <field>
          <name>fields</name>
          <version>1.0.0+</version>
          <required>true</required>
          <description>List of structured data for a given field. </description>
          <association>
            <type>StructuredFieldMetadata</type>
            <multiplicity>*</multiplicity>
          </association>
        </field>
      </fields>
      <codeSegments>
        <codeSegment>
          <version>1.0.0+</version>
          <code>
            <![CDATA[
            // Clone hooks

  public void mutatingDataStreamStructuredMetadataCloneHook(DataStreamStructuredMetadata s) {
  }

  ]]>
          </code>
        </codeSegment>
      </codeSegments>
    </class>
  </classes>
</model>